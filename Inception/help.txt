--->DOCKER-COMPOSE-COMMANDS<---
{
	# version -> Un file docker-compose.yml inizia sempre con "version" il quale indica quale versione si desidera utilizzare, la 3 è la più comune.
	# image ->  permette di specificare l' immagine sorgente per il contenitore;
	# build ->  permette di specificare il Dockerfile di origine per creare l'immagine del contenitore;
	# volume ->  consente di specificare i punti di montaggio tra il sistema host e i contenitori;
	# restart ->  permette di definire il comportamento del contenitore in caso di terminazione del processo;
	# environment ->  ti permette di impostare le variabili d'ambiente;
	# depends_on ->  permette di dire che il contenitore dipende da un altro contenitore;
	# ports ->  consente di definire le porte disponibili tra la macchina host e il contenitore.
	# network -> When you define a network in a Docker Compose file using the "networks" argument, you can specify the network driver to be used, as well as any additional options or configuration for the network.
	# You can also assign containers to specific networks by specifying the network name in the "networks" section of a container definition.
}


--->DOCKERFILE-COMMANDS<---
{
	# FROM - Defines a base image, it can be pulled from docker hub
	# (for example- if we want to create a javascript application with node as backend then we need to have node as a base image, so it can run node application.)
	# RUN - Executes command in a new image layer( we can have multiple run commands )
	# CMD - Command to be executed when running a container( It is asked to have one CMD command,
	# 		If a Dockerfile has multiple CMDs, it only applies the instructions from the last one.
	# EXPOSE - Documents which ports are exposed (It is only used for documentation)
	# ENV - Sets environment variables inside the image
	# COPY - It is used to copy your local files/directories to Docker Container.
	# ADD - It is more feature-rich version of the COPY instruction. COPY is preferred over ADD.
			# Major difference b/w ADD and COPY is that ADD allows you to copy from URL that is the source can be URL but in COPY it can only have local ones.
	# ENTRYPOINT - Define a container's executable (You cannot override and ENTRYPOINT when starting a container unless you add the --entrypoint flag.)
	# VOLUME - It defines which directory in an image should be treated as a volume.
				# The volume will be given a random name which can be found using docker inspect command.
	# WORKDIR - Defines the working directory for subsequent instructions in the Dockerfile
				# (Important point to remember that it doesn't create a new intermediate layer in Image)
}


--->Example<---
{
	#define the base image pulled
	FROM debian:buster

	#Update package and install nginx - openssl
	RUN apt update  -qq -y && \
		apt upgrade -qq -y && \
		apt install -qq -y nginx openssl

	COPY conf/alemafe.42Roma.conf /etc/nginx/sites-enabled/
	
	#Generate the SSL Certificate and Key
	#x509 -> this option outputs a self signed certificate.
	#nodes -> If a private key is created it will not be encrypted.
	#days num -> When the -x509 option is being used this specifies the number of days to certify the certificate for. The default is 30 days.
	#newkey rsa:bits -> Generate an RSA Key of 2048 bits.
	#keyout filename -> This gives the filename to write the newly created private key to.
	#Out filename -> Similar to keyout but it works for certificate.

	RUN	openssl req -x509 -nodes -days 365 -subj "/C=IT/ST=RM/O=Alemafe/OU=Gambling/CN=localhost/mail=perchelabiciemiaporcodedio@gmail.com" -newkey rsa:2048 -keyout /etc/ssl/alemafe.key -out /etc/ssl/alemafe.crt
	#This will execute nginx with the -g flag (globally apply) and the container will be executed as daemon off (Foreground and not Background)
	CMD ["nginx", "-g", "daemon off;"]
}

# Example of CMD: ["nginx", "-g", "daemon off"] -> This means that when nginx image will be executed from this docker file, this will start the NGINX web server with -g flag.
# This flag means that the following argument (like daemon off) will be global configuration directive (globally applied). The following argument in this 
# case is "daemon off". Daemon is a background process that runs on a computer system, usually without direct user interaction or input. When you put "OFF" next to 
# daemon, means that NGINX will be run in the foreground rather then background.

# When you run a docker build command with a custom Dockerfile, the commands in the Dockerfile are executed inside the Docker container that is being built.
# These commands do not affect the host machine directly, only the container being built.
# In your case, running rm -rf inside the Dockerfile should only remove files inside the container that is being built, not on the host machine.
# It's possible that the files you are trying to remove are not located in the expected path inside the container, or that there is some other issue with the Dockerfile.
# One thing to check is whether you are specifying the correct path to the files you want to remove.
# The path inside the Docker container may be different from the path on the host machine, so make sure that you are referencing the correct location inside the container.
# Another thing to check is whether the rm -rf command is being executed correctly.
# You can add RUN ls -la /path/to/files before the rm -rf command to verify that the files you want to remove are present in the expected location,
# and you can also add RUN echo "Hello World" after the rm -rf command to verify that the command is being executed at all.
# If the files you want to remove are not present in the expected location inside the container,
# or if the rm -rf command is not being executed at all, there may be an issue with your Dockerfile syntax or the build context.

